// Code generated by fastssz. DO NOT EDIT.
// Hash: ef65805d4e9f989ac4279545a32d24bc800dcc1e3aef29ece80671ef4448825a
package spectests

import (
	ssz "github.com/ferranbt/fastssz"
)

// MarshalSSZ ssz marshals the SmallTestStruct object
func (s *SmallTestStruct) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the SmallTestStruct object to a target array
func (s *SmallTestStruct) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'A'
	dst = ssz.MarshalUint16(dst, s.A)

	// Field (1) 'B'
	dst = ssz.MarshalUint16(dst, s.B)

	return
}

// UnmarshalSSZ ssz unmarshals the SmallTestStruct object
func (s *SmallTestStruct) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 4 {
		return ssz.ErrSize
	}

	// Field (0) 'A'
	s.A = ssz.UnmarshallUint16(buf[0:2])

	// Field (1) 'B'
	s.B = ssz.UnmarshallUint16(buf[2:4])

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the SmallTestStruct object
func (s *SmallTestStruct) SizeSSZ() (size int) {
	size = 4
	return
}

// HashTreeRoot ssz hashes the SmallTestStruct object
func (s *SmallTestStruct) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the SmallTestStruct object with a hasher
func (s *SmallTestStruct) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'A'
	hh.PutUint16(s.A)

	// Field (1) 'B'
	hh.PutUint16(s.B)

	hh.Merkleize(indx)
	return
}

// MarshalSSZ ssz marshals the FixedTestStruct object
func (f *FixedTestStruct) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(f)
}

// MarshalSSZTo ssz marshals the FixedTestStruct object to a target array
func (f *FixedTestStruct) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'A'
	dst = ssz.MarshalUint8(dst, f.A)

	// Field (1) 'B'
	dst = ssz.MarshalUint64(dst, f.B)

	// Field (2) 'C'
	dst = ssz.MarshalUint32(dst, f.C)

	return
}

// UnmarshalSSZ ssz unmarshals the FixedTestStruct object
func (f *FixedTestStruct) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 13 {
		return ssz.ErrSize
	}

	// Field (0) 'A'
	f.A = ssz.UnmarshallUint8(buf[0:1])

	// Field (1) 'B'
	f.B = ssz.UnmarshallUint64(buf[1:9])

	// Field (2) 'C'
	f.C = ssz.UnmarshallUint32(buf[9:13])

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the FixedTestStruct object
func (f *FixedTestStruct) SizeSSZ() (size int) {
	size = 13
	return
}

// HashTreeRoot ssz hashes the FixedTestStruct object
func (f *FixedTestStruct) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(f)
}

// HashTreeRootWith ssz hashes the FixedTestStruct object with a hasher
func (f *FixedTestStruct) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'A'
	hh.PutUint8(f.A)

	// Field (1) 'B'
	hh.PutUint64(f.B)

	// Field (2) 'C'
	hh.PutUint32(f.C)

	hh.Merkleize(indx)
	return
}

// MarshalSSZ ssz marshals the VarTestStruct object
func (v *VarTestStruct) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(v)
}

// MarshalSSZTo ssz marshals the VarTestStruct object to a target array
func (v *VarTestStruct) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(7)

	// Field (0) 'A'
	dst = ssz.MarshalUint16(dst, v.A)

	// Offset (1) 'B'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(v.B) * 2

	// Field (2) 'C'
	dst = ssz.MarshalUint8(dst, v.C)

	// Field (1) 'B'
	if len(v.B) > 1024 {
		err = ssz.ErrListTooBig
		return
	}
	for ii := 0; ii < len(v.B); ii++ {
		dst = ssz.MarshalUint16(dst, v.B[ii])
	}

	return
}

// UnmarshalSSZ ssz unmarshals the VarTestStruct object
func (v *VarTestStruct) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 7 {
		return ssz.ErrSize
	}

	tail := buf
	var o1 uint64

	// Field (0) 'A'
	v.A = ssz.UnmarshallUint16(buf[0:2])

	// Offset (1) 'B'
	if o1 = ssz.ReadOffset(buf[2:6]); o1 > size {
		return ssz.ErrOffset
	}

	if o1 < 7 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (2) 'C'
	v.C = ssz.UnmarshallUint8(buf[6:7])

	// Field (1) 'B'
	{
		buf = tail[o1:]
		num, err := ssz.DivideInt2(len(buf), 2, 1024)
		if err != nil {
			return err
		}
		v.B = ssz.ExtendUint16(v.B, num)
		for ii := 0; ii < num; ii++ {
			v.B[ii] = ssz.UnmarshallUint16(buf[ii*2 : (ii+1)*2])
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the VarTestStruct object
func (v *VarTestStruct) SizeSSZ() (size int) {
	size = 7

	// Field (1) 'B'
	size += len(v.B) * 2

	return
}

// HashTreeRoot ssz hashes the VarTestStruct object
func (v *VarTestStruct) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(v)
}

// HashTreeRootWith ssz hashes the VarTestStruct object with a hasher
func (v *VarTestStruct) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'A'
	hh.PutUint16(v.A)

	// Field (1) 'B'
	{
		if len(v.B) > 1024 {
			err = ssz.ErrListTooBig
			return
		}
		subIndx := hh.Index()
		for _, i := range v.B {
			hh.AppendUint16(i)
		}
		hh.FillUpTo32()
		numItems := uint64(len(v.B))
		hh.MerkleizeWithMixin(subIndx, numItems, ssz.CalculateLimit(1024, numItems, 2))
	}

	// Field (2) 'C'
	hh.PutUint8(v.C)

	hh.Merkleize(indx)
	return
}

// MarshalSSZ ssz marshals the ComplexTestStruct object
func (c *ComplexTestStruct) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(c)
}

// MarshalSSZTo ssz marshals the ComplexTestStruct object to a target array
func (c *ComplexTestStruct) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(71)

	// Field (0) 'A'
	dst = ssz.MarshalUint16(dst, c.A)

	// Offset (1) 'B'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(c.B) * 2

	// Field (2) 'C'
	dst = ssz.MarshalUint8(dst, c.C)

	// Offset (3) 'D'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(c.D)

	// Offset (4) 'E'
	dst = ssz.WriteOffset(dst, offset)
	if c.E == nil {
		c.E = new(VarTestStruct)
	}
	offset += c.E.SizeSSZ()

	// Field (5) 'F'
	if len(c.F) != 4 {
		err = ssz.ErrVectorLength
		return
	}
	for ii := 0; ii < 4; ii++ {
		if dst, err = c.F[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Offset (6) 'G'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(c.G); ii++ {
		offset += 4
		offset += c.G[ii].SizeSSZ()
	}

	// Field (1) 'B'
	if len(c.B) > 128 {
		err = ssz.ErrListTooBig
		return
	}
	for ii := 0; ii < len(c.B); ii++ {
		dst = ssz.MarshalUint16(dst, c.B[ii])
	}

	// Field (3) 'D'
	if len(c.D) > 256 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, c.D...)

	// Field (4) 'E'
	if dst, err = c.E.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (6) 'G'
	if len(c.G) != 2 {
		err = ssz.ErrVectorLength
		return
	}
	{
		offset = 4 * len(c.G)
		for ii := 0; ii < len(c.G); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += c.G[ii].SizeSSZ()
		}
	}
	for ii := 0; ii < len(c.G); ii++ {
		if dst, err = c.G[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	return
}

// UnmarshalSSZ ssz unmarshals the ComplexTestStruct object
func (c *ComplexTestStruct) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 71 {
		return ssz.ErrSize
	}

	tail := buf
	var o1, o3, o4, o6 uint64

	// Field (0) 'A'
	c.A = ssz.UnmarshallUint16(buf[0:2])

	// Offset (1) 'B'
	if o1 = ssz.ReadOffset(buf[2:6]); o1 > size {
		return ssz.ErrOffset
	}

	if o1 < 71 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (2) 'C'
	c.C = ssz.UnmarshallUint8(buf[6:7])

	// Offset (3) 'D'
	if o3 = ssz.ReadOffset(buf[7:11]); o3 > size || o1 > o3 {
		return ssz.ErrOffset
	}

	// Offset (4) 'E'
	if o4 = ssz.ReadOffset(buf[11:15]); o4 > size || o3 > o4 {
		return ssz.ErrOffset
	}

	// Field (5) 'F'
	c.F = make([]*FixedTestStruct, 4)
	for ii := 0; ii < 4; ii++ {
		if c.F[ii] == nil {
			c.F[ii] = new(FixedTestStruct)
		}
		if err = c.F[ii].UnmarshalSSZ(buf[15:67][ii*13 : (ii+1)*13]); err != nil {
			return err
		}
	}

	// Offset (6) 'G'
	if o6 = ssz.ReadOffset(buf[67:71]); o6 > size || o4 > o6 {
		return ssz.ErrOffset
	}

	// Field (1) 'B'
	{
		buf = tail[o1:o3]
		num, err := ssz.DivideInt2(len(buf), 2, 128)
		if err != nil {
			return err
		}
		c.B = ssz.ExtendUint16(c.B, num)
		for ii := 0; ii < num; ii++ {
			c.B[ii] = ssz.UnmarshallUint16(buf[ii*2 : (ii+1)*2])
		}
	}

	// Field (3) 'D'
	{
		buf = tail[o3:o4]
		if len(buf) > 256 {
			return ssz.ErrBytesLength
		}
		if cap(c.D) == 0 {
			c.D = make([]byte, 0, len(buf))
		}
		c.D = append(c.D, buf...)
	}

	// Field (4) 'E'
	{
		buf = tail[o4:o6]
		if c.E == nil {
			c.E = new(VarTestStruct)
		}
		if err = c.E.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}

	// Field (6) 'G'
	{
		buf = tail[o6:]
		num, err := ssz.DecodeDynamicLength(buf, 2)
		if err != nil {
			return err
		}
		c.G = make([]*VarTestStruct, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if c.G[indx] == nil {
				c.G[indx] = new(VarTestStruct)
			}
			if err = c.G[indx].UnmarshalSSZ(buf); err != nil {
				return err
			}
			return nil
		})
		if err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the ComplexTestStruct object
func (c *ComplexTestStruct) SizeSSZ() (size int) {
	size = 71

	// Field (1) 'B'
	size += len(c.B) * 2

	// Field (3) 'D'
	size += len(c.D)

	// Field (4) 'E'
	if c.E == nil {
		c.E = new(VarTestStruct)
	}
	size += c.E.SizeSSZ()

	// Field (6) 'G'
	for ii := 0; ii < len(c.G); ii++ {
		size += 4
		size += c.G[ii].SizeSSZ()
	}

	return
}

// HashTreeRoot ssz hashes the ComplexTestStruct object
func (c *ComplexTestStruct) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(c)
}

// HashTreeRootWith ssz hashes the ComplexTestStruct object with a hasher
func (c *ComplexTestStruct) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'A'
	hh.PutUint16(c.A)

	// Field (1) 'B'
	{
		if len(c.B) > 128 {
			err = ssz.ErrListTooBig
			return
		}
		subIndx := hh.Index()
		for _, i := range c.B {
			hh.AppendUint16(i)
		}
		hh.FillUpTo32()
		numItems := uint64(len(c.B))
		hh.MerkleizeWithMixin(subIndx, numItems, ssz.CalculateLimit(128, numItems, 2))
	}

	// Field (2) 'C'
	hh.PutUint8(c.C)

	// Field (3) 'D'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(c.D))
		if byteLen > 256 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.PutBytes(c.D)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (256+31)/32)
	}

	// Field (4) 'E'
	if err = c.E.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (5) 'F'
	{
		subIndx := hh.Index()
		num := uint64(len(c.F))
		if num != 4 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range c.F {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 4)
	}

	// Field (6) 'G'
	{
		subIndx := hh.Index()
		num := uint64(len(c.G))
		if num != 2 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range c.G {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 2)
	}

	hh.Merkleize(indx)
	return
}
